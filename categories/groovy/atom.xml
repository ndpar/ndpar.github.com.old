<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Side Notes]]></title>
  <link href="http://blog.ndpar.com/categories/groovy/atom.xml" rel="self"/>
  <link href="http://blog.ndpar.com/"/>
  <updated>2013-05-26T17:31:20-04:00</updated>
  <id>http://blog.ndpar.com/</id>
  <author>
    <name><![CDATA[Andrey Paramonov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exporting Solr documents]]></title>
    <link href="http://blog.ndpar.com/2012/10/01/exporting-solr-documents/"/>
    <updated>2012-10-01T08:00:00-04:00</updated>
    <id>http://blog.ndpar.com/2012/10/01/exporting-solr-documents</id>
    <content type="html"><![CDATA[<p>Recently I had to copy some documents from one <a href="http://lucene.apache.org/solr/">Solr</a> server to another. I expected Solr already had an interface that allowed me to extract documents in the same format they were inserted. In that case I would pipe an output of one curl command to another, and consider the job done. As it turned out, the format of Solr input document is different than the output format. Here is how input document looks like:</p>

<pre><code>&lt;add&gt;
    &lt;doc&gt;
        &lt;field name="id"&gt;12345&lt;/field&gt;
        &lt;field name="articlestate"&gt;published&lt;/field&gt;
        &lt;field name="articletype"&gt;news&lt;/field&gt;
        &lt;field name="body"&gt;Lorem ipsum dolor...&lt;/field&gt;
        &lt;field name="referenceid"&gt;175820&lt;/field&gt;
        &lt;field name="referenceid"&gt;163786&lt;/field&gt;
        &lt;field name="created"&gt;2011-02-15T14:57:54.766Z&lt;/field&gt;
    &lt;/doc&gt;
&lt;/add&gt;
</code></pre>

<p>Notice the flat structure of this document: all element names are the same regardless of the filed type, and arrays (referenceid) are not grouped. Now compare it to the output format. Here is what you get when you execute a query against a Solr server:</p>

<pre><code>&lt;response&gt;
    &lt;lst name="responseHeader"&gt;
        &lt;int name="status"&gt;0&lt;/int&gt;
        &lt;int name="QTime"&gt;1&lt;/int&gt;
        &lt;lst name="params"&gt;
            &lt;str name="q"&gt;id:12345&lt;/str&gt;
        &lt;/lst&gt;
    &lt;/lst&gt;
    &lt;result name="response" numFound="1" start="0"&gt;
        &lt;doc&gt;
            &lt;str name="id"&gt;12345&lt;/str&gt;
            &lt;str name="articlestate"&gt;published&lt;/str&gt;
            &lt;str name="articletype"&gt;news&lt;/str&gt;
            &lt;str name="body"&gt;Lorem ipsum dolor...&lt;/str&gt;
            &lt;arr name="referenceid"&gt;
                &lt;str&gt;175820&lt;/str&gt;
                &lt;str&gt;163786&lt;/str&gt;
            &lt;/arr&gt;
            &lt;date name="created"&gt;2011-02-15T14:57:54.766Z&lt;/date&gt;
        &lt;/doc&gt;
    &lt;/result&gt;
&lt;/response&gt;
</code></pre>

<p>Even if we ignore the response header, the structure of the response/result/doc is not the same as of input document: the element names reflect the types, the arrays are grouped. If you try to add this document to a Solr server, you will get an error &ldquo;unexpected XML tag&rdquo;, obviously. I googled for couple hours on how to convert an output document to an input, and, to my surprise, didn&rsquo;t find any solution. Therefore I implemented my own converter in Groovy, which solved the problem. I post it <a href="http://gist.github.com/3813775">here</a> in case somebody needs it.</p>

<p>Note: You can also use this script to re-index Solr.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Groovy switch statement]]></title>
    <link href="http://blog.ndpar.com/2011/06/08/functional-groovy-switch-statement/"/>
    <updated>2011-06-08T08:00:00-04:00</updated>
    <id>http://blog.ndpar.com/2011/06/08/functional-groovy-switch-statement</id>
    <content type="html"><![CDATA[<p>In the previous <a href="/2011/06/01/reversing-groovy-switch-statement">post</a> I showed how to replace chained if-else statements in Groovy with one concise switch. It was done for the special case of if-stement where every branch was evaluated using the same condition function. Today I want to make a generalization of that technique by allowing to use different conditionals.</p>

<p>Suppose your code looks like this:</p>

<pre><code>if (param % 2 == 0) {
    'even'
} else if (param % 3 == 0) {
    'threeven'
} else if (0 &lt; param) {
    'positive'
} else {
    'negative'
}
</code></pre>

<p>As long as every condition operates on the same parameter, you can replace the entire chain with a switch. In this scenario <code>param</code> becomes a switch parameter and conditions become <code>case</code> parameters of Closure type. The only thing we need to do is to override <code>Closure.isCase()</code> method as I described in the previous post. The safest way to do it is to create a category class:</p>

<pre><code>class CaseCategory {
    static boolean isCase(Closure casePredicate, Object switchParameter) {
        casePredicate.call switchParameter
    }
}
</code></pre>

<p>Now we can replace if-statement with the following switch:</p>

<pre><code>use (CaseCategory) {
    switch (param) {
        case { it % 2 == 0 } : return 'even'
        case { it % 3 == 0 } : return 'threeven'
        case { 0 &lt; it }      : return 'positive'
        default              : return 'negative'
    }
}
</code></pre>

<p>We can actually go further and extract in-line closures:</p>

<pre><code>def even = {
    it % 2 == 0
}
def threeven = {
    it % 3 == 0
}
def positive = {
    0 &lt; it
}
</code></pre>

<p>After which the code becomes even more readable:</p>

<pre><code>use (CaseCategory) {
    switch (param) {
        case even     : return 'even'
        case threeven : return 'threeven'
        case positive : return 'positive'
        default       : return 'negative'
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multimethods in Groovy]]></title>
    <link href="http://blog.ndpar.com/2011/06/05/multimethods-in-groovy/"/>
    <updated>2011-06-05T08:00:00-04:00</updated>
    <id>http://blog.ndpar.com/2011/06/05/multimethods-in-groovy</id>
    <content type="html"><![CDATA[<p>Every time I switch from Groovy to Java I have to remind myself that some things that seem so natural and work as expected in Groovy, don&rsquo;t work in Java. One of such differences is method dispatching. Groovy supports <a href="http://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a>, while Java does not. Therefore the following <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html#multimethods">code</a> works differently in Groovy and Java:</p>

<pre><code>public class A {
    public void foo(A a) { System.out.println("A/A"); }
    public void foo(B b) { System.out.println("A/B"); }
}
public class B extends A {
    public void foo(A a) { System.out.println("B/A"); }
    public void foo(B b) { System.out.println("B/B"); }
}
public class Main {
    public static void main(String[] args) {
        A a = new A();
        A b = new B();
        a.foo(a);
        b.foo(b);
    }
}

$ java Main
A/A
B/A

$ groovy Main.groovy
A/A
B/B
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reversing Groovy switch statement]]></title>
    <link href="http://blog.ndpar.com/2011/06/01/reversing-groovy-switch-statement/"/>
    <updated>2011-06-01T08:00:00-04:00</updated>
    <id>http://blog.ndpar.com/2011/06/01/reversing-groovy-switch-statement</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been working on a Groovy code that had many methods with long multibranch conditionals like this:</p>

<pre><code>def parse(message, options) {
    if (options.contains('A')) {
        parseARule message
    } else if (options.contains(2)) {
        parseSmallDigitRule message
    ...
    } else if (options.contains(something)) {
        parseSomeRule message
    } else {
        parseSomeOtherRule message
    }
}
</code></pre>

<p>Although this code is working, it is hard to see which branch is called under which condition. It would be much better if we could replace this code with something like Lisp <code>cond</code> macro. The best candidate for such a task in Groovy would be a <code>switch</code> statement. If we could only refactor the code above to something like following, it would significantly improve readability:</p>

<pre><code>def parse(message, options) {
    switch (options) {
        case 'A' : return parseARule(message)
        case 2   : return parseSmallDigitRule(message)
        ...
        case ... : return parseSomeRule(message)
        default  : return parseSomeOtherRule(message)
    }
}
</code></pre>

<p>Unfortunately, this code doesn&rsquo;t work out of the box in Groovy, but it works if we do some metaprogramming.</p>

<p>The way <code>switch</code> statement works in Groovy is a bit <a href="http://docs.codehaus.org/display/GROOVY/Logical+Branching#LogicalBranching-switchstatement">different</a> than in Java. Instead of equals() it uses isCase() method to match case-value and switch-value. The default implementation of isCase() method falls back to equals() method, but some classes, including <a href="http://groovy.codehaus.org/groovy-jdk/java/util/Collection.html#isCase(java.lang.Object)">Collection</a>, override this behaviour. That&rsquo;s why in Groovy you can do things like this:</p>

<pre><code>switch (value) {
    case ['A','E','I','O','U'] : return 'vowel'
    case 0..9                  : return 'digit'
    case Date                  : return 'date'
    default                    : return 'something else'
}
</code></pre>

<p>For our purposes we need some sort of reverse <code>switch</code>, where collection is used as a switch-value, and String and Integer are used as a case-value. To do this we need to override default implementation of isCase() method on String and Integer classes. It&rsquo;s not possible in Java, but is very easy in Groovy. You can change method implementation globally by replacing it in corresponding meta class, or locally with the help of categories. Let&rsquo;s create a category that swaps object and subject of isCase() method:</p>

<pre><code>class CaseCategory {
    static boolean isCase(String string, Collection col) {
        reverseCase(string, col)
    }
    static boolean isCase(Integer integer, Collection col) {
        reverseCase(integer, col)
    }
    // Add more overloaded methods here if needed

    private static boolean reverseCase(left, right) {
        right.isCase(left)
    }
}
</code></pre>

<p>Now we can use this category to achieve the goal we stated at the beginning of this post:</p>

<pre><code>def parse(message, options) {
    use (CaseCategory) {
        switch (options) {
            case 'A' : return parseARule(message)
            case 2   : return parseSmallDigitRule(message)
            ...
            case ... : return parseSomeRule(message)
            default  : return parseSomeOtherRule(message)
        }
    }
}
</code></pre>

<p>If you are comfortable with global method replacement, you can amend String and Integer meta classes. In this case you don&rsquo;t need to wrap <code>switch</code> statement with <code>use</code> keyword.</p>
]]></content>
  </entry>
  
</feed>
